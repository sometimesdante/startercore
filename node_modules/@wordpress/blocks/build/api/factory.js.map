{"version":3,"sources":["@wordpress/blocks/src/api/factory.js"],"names":["createBlock","name","attributes","innerBlocks","sanitizedAttributes","clientId","isValid","createBlocksFromInnerBlocksTemplate","innerBlocksOrTemplate","map","innerBlock","innerBlockTemplate","Array","isArray","__experimentalCloneSanitizedBlock","block","mergeAttributes","newInnerBlocks","cloneBlock","isPossibleTransformForSource","transform","direction","blocks","length","isMultiBlock","firstBlockName","isValidForMultiBlocks","isWildcardBlockTransform","every","isBlockType","type","sourceBlock","hasMatchingName","indexOf","isContainerGroupBlock","blockName","maybeCheckTransformIsMatch","usingMobileTransformations","getBlockTypesForPossibleFromTransforms","allBlockTypes","blockTypesWithPossibleFromTransforms","filter","blockType","fromTransforms","getBlockTransforms","findTransform","getBlockTypesForPossibleToTransforms","transformsTo","possibleTransforms","blockNames","transformation","flat","t","includes","getPossibleBlockTransformations","blockTypesForFromTransforms","blockTypesForToTransforms","Set","transforms","predicate","hooks","i","candidate","addFilter","toString","result","priority","applyFilters","blockTypeOrName","undefined","supportedMobileTransforms","filteredTransforms","transformBlockName","isMatch","switchToBlockType","blocksArray","firstBlock","sourceName","transformationsFrom","transformationsTo","transformationResults","__experimentalConvert","currentBlock","some","hasSwitchedBlock","ret","index","results","getBlockFromExample","example"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { v4 as uuid } from 'uuid';\n\n/**\n * WordPress dependencies\n */\nimport { createHooks, applyFilters } from '@wordpress/hooks';\n\n/**\n * Internal dependencies\n */\nimport {\n\tgetBlockType,\n\tgetBlockTypes,\n\tgetGroupingBlockName,\n} from './registration';\nimport {\n\tnormalizeBlockType,\n\t__experimentalSanitizeBlockAttributes,\n} from './utils';\n\n/**\n * Returns a block object given its type and attributes.\n *\n * @param {string} name        Block name.\n * @param {Object} attributes  Block attributes.\n * @param {?Array} innerBlocks Nested blocks.\n *\n * @return {Object} Block object.\n */\nexport function createBlock( name, attributes = {}, innerBlocks = [] ) {\n\tconst sanitizedAttributes = __experimentalSanitizeBlockAttributes(\n\t\tname,\n\t\tattributes\n\t);\n\n\tconst clientId = uuid();\n\n\t// Blocks are stored with a unique ID, the assigned type name, the block\n\t// attributes, and their inner blocks.\n\treturn {\n\t\tclientId,\n\t\tname,\n\t\tisValid: true,\n\t\tattributes: sanitizedAttributes,\n\t\tinnerBlocks,\n\t};\n}\n\n/**\n * Given an array of InnerBlocks templates or Block Objects,\n * returns an array of created Blocks from them.\n * It handles the case of having InnerBlocks as Blocks by\n * converting them to the proper format to continue recursively.\n *\n * @param {Array} innerBlocksOrTemplate Nested blocks or InnerBlocks templates.\n *\n * @return {Object[]} Array of Block objects.\n */\nexport function createBlocksFromInnerBlocksTemplate(\n\tinnerBlocksOrTemplate = []\n) {\n\treturn innerBlocksOrTemplate.map( ( innerBlock ) => {\n\t\tconst innerBlockTemplate = Array.isArray( innerBlock )\n\t\t\t? innerBlock\n\t\t\t: [\n\t\t\t\t\tinnerBlock.name,\n\t\t\t\t\tinnerBlock.attributes,\n\t\t\t\t\tinnerBlock.innerBlocks,\n\t\t\t  ];\n\t\tconst [ name, attributes, innerBlocks = [] ] = innerBlockTemplate;\n\t\treturn createBlock(\n\t\t\tname,\n\t\t\tattributes,\n\t\t\tcreateBlocksFromInnerBlocksTemplate( innerBlocks )\n\t\t);\n\t} );\n}\n\n/**\n * Given a block object, returns a copy of the block object while sanitizing its attributes,\n * optionally merging new attributes and/or replacing its inner blocks.\n *\n * @param {Object} block           Block instance.\n * @param {Object} mergeAttributes Block attributes.\n * @param {?Array} newInnerBlocks  Nested blocks.\n *\n * @return {Object} A cloned block.\n */\nexport function __experimentalCloneSanitizedBlock(\n\tblock,\n\tmergeAttributes = {},\n\tnewInnerBlocks\n) {\n\tconst clientId = uuid();\n\n\tconst sanitizedAttributes = __experimentalSanitizeBlockAttributes(\n\t\tblock.name,\n\t\t{\n\t\t\t...block.attributes,\n\t\t\t...mergeAttributes,\n\t\t}\n\t);\n\n\treturn {\n\t\t...block,\n\t\tclientId,\n\t\tattributes: sanitizedAttributes,\n\t\tinnerBlocks:\n\t\t\tnewInnerBlocks ||\n\t\t\tblock.innerBlocks.map( ( innerBlock ) =>\n\t\t\t\t__experimentalCloneSanitizedBlock( innerBlock )\n\t\t\t),\n\t};\n}\n\n/**\n * Given a block object, returns a copy of the block object,\n * optionally merging new attributes and/or replacing its inner blocks.\n *\n * @param {Object} block           Block instance.\n * @param {Object} mergeAttributes Block attributes.\n * @param {?Array} newInnerBlocks  Nested blocks.\n *\n * @return {Object} A cloned block.\n */\nexport function cloneBlock( block, mergeAttributes = {}, newInnerBlocks ) {\n\tconst clientId = uuid();\n\n\treturn {\n\t\t...block,\n\t\tclientId,\n\t\tattributes: {\n\t\t\t...block.attributes,\n\t\t\t...mergeAttributes,\n\t\t},\n\t\tinnerBlocks:\n\t\t\tnewInnerBlocks ||\n\t\t\tblock.innerBlocks.map( ( innerBlock ) => cloneBlock( innerBlock ) ),\n\t};\n}\n\n/**\n * Returns a boolean indicating whether a transform is possible based on\n * various bits of context.\n *\n * @param {Object} transform The transform object to validate.\n * @param {string} direction Is this a 'from' or 'to' transform.\n * @param {Array}  blocks    The blocks to transform from.\n *\n * @return {boolean} Is the transform possible?\n */\nconst isPossibleTransformForSource = ( transform, direction, blocks ) => {\n\tif ( ! blocks.length ) {\n\t\treturn false;\n\t}\n\n\t// If multiple blocks are selected, only multi block transforms\n\t// or wildcard transforms are allowed.\n\tconst isMultiBlock = blocks.length > 1;\n\tconst firstBlockName = blocks[ 0 ].name;\n\tconst isValidForMultiBlocks =\n\t\tisWildcardBlockTransform( transform ) ||\n\t\t! isMultiBlock ||\n\t\ttransform.isMultiBlock;\n\tif ( ! isValidForMultiBlocks ) {\n\t\treturn false;\n\t}\n\n\t// Check non-wildcard transforms to ensure that transform is valid\n\t// for a block selection of multiple blocks of different types.\n\tif (\n\t\t! isWildcardBlockTransform( transform ) &&\n\t\t! blocks.every( ( block ) => block.name === firstBlockName )\n\t) {\n\t\treturn false;\n\t}\n\n\t// Only consider 'block' type transforms as valid.\n\tconst isBlockType = transform.type === 'block';\n\tif ( ! isBlockType ) {\n\t\treturn false;\n\t}\n\n\t// Check if the transform's block name matches the source block (or is a wildcard)\n\t// only if this is a transform 'from'.\n\tconst sourceBlock = blocks[ 0 ];\n\tconst hasMatchingName =\n\t\tdirection !== 'from' ||\n\t\ttransform.blocks.indexOf( sourceBlock.name ) !== -1 ||\n\t\tisWildcardBlockTransform( transform );\n\tif ( ! hasMatchingName ) {\n\t\treturn false;\n\t}\n\n\t// Don't allow single Grouping blocks to be transformed into\n\t// a Grouping block.\n\tif (\n\t\t! isMultiBlock &&\n\t\tdirection === 'from' &&\n\t\tisContainerGroupBlock( sourceBlock.name ) &&\n\t\tisContainerGroupBlock( transform.blockName )\n\t) {\n\t\treturn false;\n\t}\n\n\t// If the transform has a `isMatch` function specified, check that it returns true.\n\tif ( ! maybeCheckTransformIsMatch( transform, blocks ) ) {\n\t\treturn false;\n\t}\n\n\tif (\n\t\ttransform.usingMobileTransformations &&\n\t\tisWildcardBlockTransform( transform ) &&\n\t\t! isContainerGroupBlock( sourceBlock.name )\n\t) {\n\t\treturn false;\n\t}\n\n\treturn true;\n};\n\n/**\n * Returns block types that the 'blocks' can be transformed into, based on\n * 'from' transforms on other blocks.\n *\n * @param {Array} blocks The blocks to transform from.\n *\n * @return {Array} Block types that the blocks can be transformed into.\n */\nconst getBlockTypesForPossibleFromTransforms = ( blocks ) => {\n\tif ( ! blocks.length ) {\n\t\treturn [];\n\t}\n\n\tconst allBlockTypes = getBlockTypes();\n\n\t// filter all blocks to find those with a 'from' transform.\n\tconst blockTypesWithPossibleFromTransforms = allBlockTypes.filter(\n\t\t( blockType ) => {\n\t\t\tconst fromTransforms = getBlockTransforms( 'from', blockType.name );\n\t\t\treturn !! findTransform( fromTransforms, ( transform ) => {\n\t\t\t\treturn isPossibleTransformForSource(\n\t\t\t\t\ttransform,\n\t\t\t\t\t'from',\n\t\t\t\t\tblocks\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\t);\n\n\treturn blockTypesWithPossibleFromTransforms;\n};\n\n/**\n * Returns block types that the 'blocks' can be transformed into, based on\n * the source block's own 'to' transforms.\n *\n * @param {Array} blocks The blocks to transform from.\n *\n * @return {Array} Block types that the source can be transformed into.\n */\nconst getBlockTypesForPossibleToTransforms = ( blocks ) => {\n\tif ( ! blocks.length ) {\n\t\treturn [];\n\t}\n\n\tconst sourceBlock = blocks[ 0 ];\n\tconst blockType = getBlockType( sourceBlock.name );\n\tconst transformsTo = blockType\n\t\t? getBlockTransforms( 'to', blockType.name )\n\t\t: [];\n\n\t// filter all 'to' transforms to find those that are possible.\n\tconst possibleTransforms = transformsTo.filter( ( transform ) => {\n\t\treturn (\n\t\t\ttransform && isPossibleTransformForSource( transform, 'to', blocks )\n\t\t);\n\t} );\n\n\t// Build a list of block names using the possible 'to' transforms.\n\tconst blockNames = possibleTransforms\n\t\t.map( ( transformation ) => transformation.blocks )\n\t\t.flat();\n\n\t// Map block names to block types.\n\treturn blockNames.map( ( name ) =>\n\t\tname === '*' ? name : getBlockType( name )\n\t);\n};\n\n/**\n * Determines whether transform is a \"block\" type\n * and if so whether it is a \"wildcard\" transform\n * ie: targets \"any\" block type\n *\n * @param {Object} t the Block transform object\n *\n * @return {boolean} whether transform is a wildcard transform\n */\nexport const isWildcardBlockTransform = ( t ) =>\n\tt &&\n\tt.type === 'block' &&\n\tArray.isArray( t.blocks ) &&\n\tt.blocks.includes( '*' );\n\n/**\n * Determines whether the given Block is the core Block which\n * acts as a container Block for other Blocks as part of the\n * Grouping mechanics\n *\n * @param {string} name the name of the Block to test against\n *\n * @return {boolean} whether or not the Block is the container Block type\n */\nexport const isContainerGroupBlock = ( name ) =>\n\tname === getGroupingBlockName();\n\n/**\n * Returns an array of block types that the set of blocks received as argument\n * can be transformed into.\n *\n * @param {Array} blocks Blocks array.\n *\n * @return {Array} Block types that the blocks argument can be transformed to.\n */\nexport function getPossibleBlockTransformations( blocks ) {\n\tif ( ! blocks.length ) {\n\t\treturn [];\n\t}\n\n\tconst blockTypesForFromTransforms =\n\t\tgetBlockTypesForPossibleFromTransforms( blocks );\n\tconst blockTypesForToTransforms =\n\t\tgetBlockTypesForPossibleToTransforms( blocks );\n\n\treturn [\n\t\t...new Set( [\n\t\t\t...blockTypesForFromTransforms,\n\t\t\t...blockTypesForToTransforms,\n\t\t] ),\n\t];\n}\n\n/**\n * Given an array of transforms, returns the highest-priority transform where\n * the predicate function returns a truthy value. A higher-priority transform\n * is one with a lower priority value (i.e. first in priority order). Returns\n * null if the transforms set is empty or the predicate function returns a\n * falsey value for all entries.\n *\n * @param {Object[]} transforms Transforms to search.\n * @param {Function} predicate  Function returning true on matching transform.\n *\n * @return {?Object} Highest-priority transform candidate.\n */\nexport function findTransform( transforms, predicate ) {\n\t// The hooks library already has built-in mechanisms for managing priority\n\t// queue, so leverage via locally-defined instance.\n\tconst hooks = createHooks();\n\n\tfor ( let i = 0; i < transforms.length; i++ ) {\n\t\tconst candidate = transforms[ i ];\n\t\tif ( predicate( candidate ) ) {\n\t\t\thooks.addFilter(\n\t\t\t\t'transform',\n\t\t\t\t'transform/' + i.toString(),\n\t\t\t\t( result ) => ( result ? result : candidate ),\n\t\t\t\tcandidate.priority\n\t\t\t);\n\t\t}\n\t}\n\n\t// Filter name is arbitrarily chosen but consistent with above aggregation.\n\treturn hooks.applyFilters( 'transform', null );\n}\n\n/**\n * Returns normal block transforms for a given transform direction, optionally\n * for a specific block by name, or an empty array if there are no transforms.\n * If no block name is provided, returns transforms for all blocks. A normal\n * transform object includes `blockName` as a property.\n *\n * @param {string}        direction       Transform direction (\"to\", \"from\").\n * @param {string|Object} blockTypeOrName Block type or name.\n *\n * @return {Array} Block transforms for direction.\n */\nexport function getBlockTransforms( direction, blockTypeOrName ) {\n\t// When retrieving transforms for all block types, recurse into self.\n\tif ( blockTypeOrName === undefined ) {\n\t\treturn getBlockTypes()\n\t\t\t.map( ( { name } ) => getBlockTransforms( direction, name ) )\n\t\t\t.flat();\n\t}\n\n\t// Validate that block type exists and has array of direction.\n\tconst blockType = normalizeBlockType( blockTypeOrName );\n\tconst { name: blockName, transforms } = blockType || {};\n\tif ( ! transforms || ! Array.isArray( transforms[ direction ] ) ) {\n\t\treturn [];\n\t}\n\n\tconst usingMobileTransformations =\n\t\ttransforms.supportedMobileTransforms &&\n\t\tArray.isArray( transforms.supportedMobileTransforms );\n\tconst filteredTransforms = usingMobileTransformations\n\t\t? transforms[ direction ].filter( ( t ) => {\n\t\t\t\tif ( t.type === 'raw' ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tif ( ! t.blocks || ! t.blocks.length ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif ( isWildcardBlockTransform( t ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn t.blocks.every( ( transformBlockName ) =>\n\t\t\t\t\ttransforms.supportedMobileTransforms.includes(\n\t\t\t\t\t\ttransformBlockName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t  } )\n\t\t: transforms[ direction ];\n\n\t// Map transforms to normal form.\n\treturn filteredTransforms.map( ( transform ) => ( {\n\t\t...transform,\n\t\tblockName,\n\t\tusingMobileTransformations,\n\t} ) );\n}\n\n/**\n * Checks that a given transforms isMatch method passes for given source blocks.\n *\n * @param {Object} transform A transform object.\n * @param {Array}  blocks    Blocks array.\n *\n * @return {boolean} True if given blocks are a match for the transform.\n */\nfunction maybeCheckTransformIsMatch( transform, blocks ) {\n\tif ( typeof transform.isMatch !== 'function' ) {\n\t\treturn true;\n\t}\n\tconst sourceBlock = blocks[ 0 ];\n\tconst attributes = transform.isMultiBlock\n\t\t? blocks.map( ( block ) => block.attributes )\n\t\t: sourceBlock.attributes;\n\tconst block = transform.isMultiBlock ? blocks : sourceBlock;\n\n\treturn transform.isMatch( attributes, block );\n}\n\n/**\n * Switch one or more blocks into one or more blocks of the new block type.\n *\n * @param {Array|Object} blocks Blocks array or block object.\n * @param {string}       name   Block name.\n *\n * @return {?Array} Array of blocks or null.\n */\nexport function switchToBlockType( blocks, name ) {\n\tconst blocksArray = Array.isArray( blocks ) ? blocks : [ blocks ];\n\tconst isMultiBlock = blocksArray.length > 1;\n\tconst firstBlock = blocksArray[ 0 ];\n\tconst sourceName = firstBlock.name;\n\n\t// Find the right transformation by giving priority to the \"to\"\n\t// transformation.\n\tconst transformationsFrom = getBlockTransforms( 'from', name );\n\tconst transformationsTo = getBlockTransforms( 'to', sourceName );\n\n\tconst transformation =\n\t\tfindTransform(\n\t\t\ttransformationsTo,\n\t\t\t( t ) =>\n\t\t\t\tt.type === 'block' &&\n\t\t\t\tt.blocks.indexOf( name ) !== -1 &&\n\t\t\t\t( ! isMultiBlock || t.isMultiBlock ) &&\n\t\t\t\tmaybeCheckTransformIsMatch( t, blocksArray )\n\t\t) ||\n\t\tfindTransform(\n\t\t\ttransformationsFrom,\n\t\t\t( t ) =>\n\t\t\t\tt.type === 'block' &&\n\t\t\t\t( isWildcardBlockTransform( t ) ||\n\t\t\t\t\tt.blocks.indexOf( sourceName ) !== -1 ) &&\n\t\t\t\t( ! isMultiBlock || t.isMultiBlock ) &&\n\t\t\t\tmaybeCheckTransformIsMatch( t, blocksArray )\n\t\t);\n\n\t// Stop if there is no valid transformation.\n\tif ( ! transformation ) {\n\t\treturn null;\n\t}\n\n\tlet transformationResults;\n\n\tif ( transformation.isMultiBlock ) {\n\t\tif ( '__experimentalConvert' in transformation ) {\n\t\t\ttransformationResults =\n\t\t\t\ttransformation.__experimentalConvert( blocksArray );\n\t\t} else {\n\t\t\ttransformationResults = transformation.transform(\n\t\t\t\tblocksArray.map( ( currentBlock ) => currentBlock.attributes ),\n\t\t\t\tblocksArray.map( ( currentBlock ) => currentBlock.innerBlocks )\n\t\t\t);\n\t\t}\n\t} else if ( '__experimentalConvert' in transformation ) {\n\t\ttransformationResults =\n\t\t\ttransformation.__experimentalConvert( firstBlock );\n\t} else {\n\t\ttransformationResults = transformation.transform(\n\t\t\tfirstBlock.attributes,\n\t\t\tfirstBlock.innerBlocks\n\t\t);\n\t}\n\n\t// Ensure that the transformation function returned an object or an array\n\t// of objects.\n\tif (\n\t\ttransformationResults === null ||\n\t\ttypeof transformationResults !== 'object'\n\t) {\n\t\treturn null;\n\t}\n\n\t// If the transformation function returned a single object, we want to work\n\t// with an array instead.\n\ttransformationResults = Array.isArray( transformationResults )\n\t\t? transformationResults\n\t\t: [ transformationResults ];\n\n\t// Ensure that every block object returned by the transformation has a\n\t// valid block type.\n\tif (\n\t\ttransformationResults.some(\n\t\t\t( result ) => ! getBlockType( result.name )\n\t\t)\n\t) {\n\t\treturn null;\n\t}\n\n\t// When unwrapping blocks (`switchToBlockType( wrapperblocks, '*' )`), do\n\t// not run filters on the unwrapped blocks. They shoud remain as they are.\n\tif ( name === '*' ) {\n\t\treturn transformationResults;\n\t}\n\n\tconst hasSwitchedBlock = transformationResults.some(\n\t\t( result ) => result.name === name\n\t);\n\n\t// Ensure that at least one block object returned by the transformation has\n\t// the expected \"destination\" block type.\n\tif ( ! hasSwitchedBlock ) {\n\t\treturn null;\n\t}\n\n\tconst ret = transformationResults.map( ( result, index, results ) => {\n\t\t/**\n\t\t * Filters an individual transform result from block transformation.\n\t\t * All of the original blocks are passed, since transformations are\n\t\t * many-to-many, not one-to-one.\n\t\t *\n\t\t * @param {Object}   transformedBlock The transformed block.\n\t\t * @param {Object[]} blocks           Original blocks transformed.\n\t\t * @param {Object[]} index            Index of the transformed block on the array of results.\n\t\t * @param {Object[]} results          An array all the blocks that resulted from the transformation.\n\t\t */\n\t\treturn applyFilters(\n\t\t\t'blocks.switchToBlockType.transformedBlock',\n\t\t\tresult,\n\t\t\tblocks,\n\t\t\tindex,\n\t\t\tresults\n\t\t);\n\t} );\n\n\treturn ret;\n}\n\n/**\n * Create a block object from the example API.\n *\n * @param {string} name\n * @param {Object} example\n *\n * @return {Object} block.\n */\nexport const getBlockFromExample = ( name, example ) => {\n\treturn createBlock(\n\t\tname,\n\t\texample.attributes,\n\t\t( example.innerBlocks ?? [] ).map( ( innerBlock ) =>\n\t\t\tgetBlockFromExample( innerBlock.name, innerBlock )\n\t\t)\n\t);\n};\n"]}